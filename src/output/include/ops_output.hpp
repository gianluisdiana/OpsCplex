// clang-format off
/**
 * University: Universidad de La Laguna
 * Center: Escuela Superior de Ingeniería y Tecnología
 * Grade: Ingeniería Informática
 * Subject: T.F.G.
 * Course: Fifth
 * Institutional email: gian.diana.28@ull.edu.es
 *
 * @file ops_output.hpp
 * @author Gian Luis Bolivar Diana
 * @version 1.0.0
 * @date April 10, 2024
 * @copyright Copyright (c) 2024
 *
 * @brief File containing the description of the output generated after solving
 * the O.P.S. problem.
 *
 * @see GitHub repository: @link https://github.com/gianluisdiana/OpsCplex @endlink
 * @see Selective routing problem with synchronization: @link https://www.sciencedirect.com/science/article/pii/S0305054821002161?ref=cra_js_challenge&fr=RR-1 @endlink
 * @see EMIR Telescope: @link https://www.gtc.iac.es/instruments/emir/ @endlink
 * @see Google style guide: @link https://google.github.io/styleguide/cppguide.html @endlink
 */
// clang-format on

#ifndef EMIR_OPS_OUTPUT_HPP_
#define EMIR_OPS_OUTPUT_HPP_

#include <memory>

#include <ops_input.hpp>

namespace emir {

/** @brief This class represents the output of the O.P.S. problem. */
class OpsOutput {
 public:
  /**
   * @brief Assign the input and resize the attributes.
   *
   * @param input The input of the O.P.S. problem.
   */
  explicit OpsOutput(const OpsInput &input);

  /** @brief Copy constructor. */
  OpsOutput(const OpsOutput &output);

  /** @brief Default move constructor. */
  OpsOutput(OpsOutput &&) = default;

  /** @brief Destroy the OpsOutput object. */
  ~OpsOutput() = default;

  // ------------------------------ Setters -------------------------------- //

  /**
   * @brief Get each arc of every graph and check if the value in the given
   * vector is 1 or 0. If it is 1, set the value of the arc as true.
   *
   * @param used_arcs The vector with the values of the arcs of the graph.
   */
  void setUsedArcs(const std::vector<double> &used_arcs);

  /**
   * @brief Sets which nodes are visited in the solution.
   *
   * @param observed_objects The vector with the values of the nodes of the
   * graph.
   */
  void setObservedObjects(const std::vector<double> &observed_objects);

  /**
   * @brief Set the time spent in each node.
   *
   * @param time_at_objects The vector with the values of the time spent in each
   * node.
   */
  void setTimeAtObjects(const std::vector<double> &time_at_objects);

  /**
   * @brief Set the time spent to solve the problem.
   *
   * @param time_spent The time spent to solve the problem.
   */
  void setTimeSpent(const long time_spent) {
    time_elapsed_ = time_spent;
  }

  // ------------------------------ Operators ------------------------------ //

  /**
   * @brief Overload of the copy assignment operator.
   *
   * @param output The output to be copied.
   * @return The output copied.
   */
  OpsOutput &operator=(const OpsOutput &output);

  /** @brief Default move assignment. */
  OpsOutput &operator=(OpsOutput &&) = default;

  /**
   * @brief Overload of the << operator to print a solution of the O.P.S.
   * problem.
   *
   * @param output_stream Represents the outflow.
   * @param output The output, generated by a solver, to be printed.
   * @return The outflow with the output in a JSON format.
   */
  friend std::ostream &
  operator<<(std::ostream &output_stream, const OpsOutput &output);

 private:
  // Maximum time margin for checking the feasibility of the solution
  static const double kMaxTimeMargin;

  // ----------------------------- Attributes ------------------------------ //

  // The input of the O.P.S. problem.
  std::unique_ptr<const OpsInput> input_;
  // Represents the connections between the nodes for each graph.
  std::vector<std::vector<unsigned int>> used_arcs_;
  // Represents which nodes are visited in the solution.
  std::vector<bool> observed_objects_;
  // Represents the time spent in each node.
  std::vector<double> time_at_objects_;
  // The time elapsed to solve the problem.
  long time_elapsed_ {-1};

  // ------------------------------ Getters -------------------------------- //

  /**
   * @brief Gives read-only access to the used arc in the given position.
   *
   * @param graph_idx The index of the graph.
   * @param arc_endpoints The origin and destination of the arc.
   * @return A constant reference to whether the arc is used or not.
   */
  [[nodiscard]] bool arcWasUsed(
    const unsigned int graph_idx, const ArcEndpoints arc_endpoints
  ) const {
    return used_arcs_[graph_idx][arc_endpoints.origin_id] ==
           arc_endpoints.destination_id;
  }

  /**
   * @brief Gets the value of the solution.
   * @details To calculate the objective value of the solution we need to sum
   * the priority of the objects visited in the solution.
   *
   * @return The value of the solution.
   */
  [[nodiscard]] long getTotalProfit() const;

  // --------------------------- Utility methods --------------------------- //

  /**
   * @brief Count the number of arrival and departure arcs of each node.
   *
   * @return A pair with the amount of arrival and departure arcs of each node,
   * in that order.
   */
  [[nodiscard]] std::pair<std::vector<int>, std::vector<int>>
  countArrivesAndDepartures() const;

  // ------------------------------- Checks ------------------------------- //

  /**
   * @brief Checks if the constraints of the mathematical model are beeing
   * satisfied.
   * @details The constraints are:
   *  - The first and last node is visited in each sliding bar.
   *  - Each node must have the same number of arrival and departure arcs.
   *  - The time spent at moment of visiting each node is less than the
   *  maximum time.
   */
  void check() const;

  /**
   * @brief Checks if the first and last node is visited in each sliding bar and
   * if each node has the same number of arrival and departure arcs.
   */
  void checkArcs() const;

  /**
   * @brief Checks if the time spent at moment of visiting each node is less
   * than the maximum time.
   */
  void checkTime() const;
};

}  // namespace emir

#endif  // EMIR_OPS_OUTPUT_HPP_