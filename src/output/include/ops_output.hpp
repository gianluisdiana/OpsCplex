#ifndef _EMIR_OPS_OUTPUT_HPP_
#define _EMIR_OPS_OUTPUT_HPP_

#include <ops_input.hpp>

namespace emir {

class OpsOutput {
 public:
  OpsOutput(const OpsInput &input);

  ~OpsOutput();

  bool set(
    const std::vector<double> &x, const std::vector<double> &y,
    const std::vector<double> &s, bool optimal = true
  );

  inline int get_x(const int k, const int i, const int j) const {
    return x_(k * input_.getN() + i + 1, j + 1);
  }

  inline int &set_x(const int k, const int i, const int j) {
    return x_(k * input_.getN() + i + 1, j + 1);
  }

  int get_obj() const;

  inline double length() const {
    return s_[y_.size() - 1];
  }

  int n_customers() const;

  std::ostream &write(std::ostream &os) const;

  void write_statistics(std::ostream &os) const;

  void init_t_cost();

  bool check();

  // ------------------------------ Operators ------------------------------ //

  /**
   * @brief Overload of the << operator to print a solution of the O.P.S.
   * problem.
   *
   * @param os Represents the outflow.
   * @param output The output, generated by a solver, to be printed.
   * @return The outflow with the output in a JSON format.
   */
  friend std::ostream &operator<<(std::ostream &os, const OpsOutput &output);

 private:
  // Maximum time margin for checking the feasibility of the solution
  static const double kMaxTimeMargin;

  const OpsInput &input_;

  GOMA::matrix<int> x_;
  std::vector<int> y_;
  std::vector<double> s_;
  std::vector<double> h_;

  GOMA::matrix<int> t_cost_;

  bool optimal_;
  bool found_;
};

}  // namespace emir

#endif  // _EMIR_OPS_OUTPUT_HPP_