#ifndef _EMIR_OPS_OUTPUT_HPP_
#define _EMIR_OPS_OUTPUT_HPP_

#include <ops_input.hpp>

namespace emir {

/** @brief This class represents the output of the O.P.S. problem. */
class OpsOutput {
 public:
  /**
   * @brief Assign the input and resize the attributes.
   *
   * @param input The input of the O.P.S. problem.
   */
  OpsOutput(const OpsInput &input);

  /** @brief Empty destructor. */
  ~OpsOutput();

  /**
   * @brief Set the output of the O.P.S. problem.
   * @details Assigns the values of the solution to the attributes of the class,
   * checking if they have with the expected format.
   *
   * @param x The values of the arcs of the graph.
   * @param y The values of the nodes of the graph.
   * @param s The values of the time spent in each node.
   * @param isOptimal Whether the solution is optimal or not.
   */
  void set(
    const std::vector<double> &x, const std::vector<double> &y,
    const std::vector<double> &s, bool isOptimal = true
  );

  inline double length() const {
    return s_[y_.size() - 1];
  }

  std::ostream &write(std::ostream &os) const;

  void write_statistics(std::ostream &os) const;

  // ------------------------------ Operators ------------------------------ //

  /**
   * @brief Overload of the << operator to print a solution of the O.P.S.
   * problem.
   *
   * @param os Represents the outflow.
   * @param output The output, generated by a solver, to be printed.
   * @return The outflow with the output in a JSON format.
   */
  friend std::ostream &operator<<(std::ostream &os, const OpsOutput &output);

 private:
  // Maximum time margin for checking the feasibility of the solution
  static const double kMaxTimeMargin;

  const OpsInput &input_;

  // The matrix that represents the arcs of the graph.
  GOMA::matrix<int> x_;
  // Represents which nodes are visited in the solution.
  std::vector<int> y_;
  // Represents the time spent in each node.
  std::vector<double> s_;

  std::vector<double> h_;

  bool optimal_;
  bool found_;

  // ------------------------------ Setters -------------------------------- //

  /**
   * @brief Set the value of the arc (i, j) of the graph k as true.
   *
   * @param k The index of the graph.
   * @param i The origin of the arc.
   * @param j The destination of the arc.
   */
  inline void setXAsTrue(const int k, const int i, const int j) {
    x_(k * input_.getN() + i + 1, j + 1) = 1;
  }

  /**
   * @brief Get each arc of every graph and check if the value in the given
   * vector is 1 or 0. If it is 1, set the value of the arc as true.
   *
   * @param x The vector with the values of the arcs of the graph.
   */
  void setX(const std::vector<double> &x);

  /**
   * @brief Sets which nodes are visited in the solution.
   *
   * @param y The vector with the values of the nodes of the graph.
   */
  void setY(const std::vector<double> &y);

  /**
   * @brief Set the time spent in each node.
   *
   * @param s The vector with the values of the time spent in each node.
   */
  void setS(const std::vector<double> &s);

  // ------------------------------ Getters -------------------------------- //

  /** @brief Gives readonly access to the x_ value in the given position. */
  inline int getX(const int k, const int i, const int j) const {
    return x_(k * input_.getN() + i + 1, j + 1);
  }

  /** @brief Gets the number of objects visited in the solution. */
  std::size_t getObjectsVisited() const;

  /**
   * @brief Gets the value of the solution.
   * @details To calculate the objective value of the solution we need to sum
   * the priority of the objects visited in the solution.
   *
   * @return The value of the solution.
   */
  int getTotalProfit() const;

  // -------------------------- Utility methods ---------------------------- //

  /**
   * @brief Checks if the constraints of the mathematical model are beeing
   * satisfied.
   * @details The constraints are:
   *  - The first and last node is visited in each sliding bar.
   *  - Each node must have the same number of arrival and departure arcs.
   *  - The time spent at moment of visiting each node is less than the
   *  maximum time.
   */
  void check() const;

  /**
   * @brief Checks if the first and last node is visited in each sliding bar and
   * if each node has the same number of arrival and departure arcs.
   */
  void checkArcs() const;

  /**
   * @brief Checks if the time spent at moment of visiting each node is less than
   * the maximum time.
   */
  void checkTime() const;

};

}  // namespace emir

#endif  // _EMIR_OPS_OUTPUT_HPP_